#ifndef COMPACT_AST_H
#define COMPACT_AST_H

#include "location.hh" // location.hh is generated by bison
#include <memory>
#include <string>

namespace compact {
struct Location {
  size_t line;
  size_t column;
  std::string file;

  Location(const compact::location &location)
      : line(location.begin.line), column(location.begin.column),
        file(location.begin.filename ? *location.begin.filename : "<Unknown>") {
  }
};

enum class AstNodeType { VARIABLE_REFERENCE, NUMBER, BINARY_EXPRESSION };

class AstNode {
  Location location;
  AstNodeType nodeType;

public:
  AstNode(Location location, AstNodeType type)
      : location(location), nodeType(nodeType) {}
  virtual ~AstNode() {}

  const Location &getLocation() const { return location; }
  AstNodeType getNodeType() const { return nodeType; }
};

class VariableReferenceNode : public AstNode {
  std::string name;

public:
  VariableReferenceNode(Location location, std::string name)
      : AstNode(location, AstNodeType::VARIABLE_REFERENCE), name(name) {}

  const std::string &getName() const { return name; }
};

class NumberNode : public AstNode {
  double value;

public:
  NumberNode(Location location, double value)
      : AstNode(location, AstNodeType::NUMBER), value(value) {}

  double getValue() const { return value; }
};

enum class BinaryOperator { ADD, SUBTRACT, MULTIPLY, DIVIDE, MODULO };

class BinaryExpressionNode : public AstNode {
  std::unique_ptr<AstNode> left;
  std::unique_ptr<AstNode> right;
  BinaryOperator op;

public:
  BinaryExpressionNode(Location location, BinaryOperator op,
                       std::unique_ptr<AstNode> left,
                       std::unique_ptr<AstNode> right)
      : AstNode(location, AstNodeType::BINARY_EXPRESSION), op(op),
        left(std::move(left)), right(std::move(right)) {}

  const AstNode &getLeft() const { return *left; }
  const AstNode &getRight() const { return *right; }
  BinaryOperator getOperator() const { return op; }
};

} // namespace compact

#endif